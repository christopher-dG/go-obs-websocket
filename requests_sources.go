package obsws

import (
	"errors"
	"time"
)

// This file is automatically generated.
// https://github.com/christopher-dG/go-obs-websocket/blob/master/codegen/protocol.py

// GetSourcesListRequest : List all sources available in the running OBS instance.
//
// Since obs-websocket version: 4.3.0.
//
// https://github.com/Palakis/obs-websocket/blob/4.x-current/docs/generated/protocol.md#getsourceslist
type GetSourcesListRequest struct {
	_request `json:",squash"`
	response chan GetSourcesListResponse
}

// NewGetSourcesListRequest returns a new GetSourcesListRequest.
func NewGetSourcesListRequest() GetSourcesListRequest {
	return GetSourcesListRequest{
		_request{
			ID_:   GetMessageID(),
			Type_: "GetSourcesList",
			err:   make(chan error, 1),
		},
		make(chan GetSourcesListResponse, 1),
	}
}

// Send sends the request.
func (r *GetSourcesListRequest) Send(c Client) error {
	if r.sent {
		return ErrAlreadySent
	}
	future, err := c.SendRequest(r)
	if err != nil {
		return err
	}
	r.sent = true
	go func() {
		m := <-future
		var resp GetSourcesListResponse
		if err = mapToStruct(m, &resp); err != nil {
			r.err <- err
		} else if resp.Status() != StatusOK {
			r.err <- errors.New(resp.Error())
		} else {
			r.response <- resp
		}
	}()
	return nil
}

// Receive waits for the response.
func (r GetSourcesListRequest) Receive() (GetSourcesListResponse, error) {
	if !r.sent {
		return GetSourcesListResponse{}, ErrNotSent
	}
	if receiveTimeout == 0 {
		select {
		case resp := <-r.response:
			return resp, nil
		case err := <-r.err:
			return GetSourcesListResponse{}, err
		}
	} else {
		select {
		case resp := <-r.response:
			return resp, nil
		case err := <-r.err:
			return GetSourcesListResponse{}, err
		case <-time.After(receiveTimeout):
			return GetSourcesListResponse{}, ErrReceiveTimeout
		}
	}
}

// SendReceive sends the request then immediately waits for the response.
func (r GetSourcesListRequest) SendReceive(c Client) (GetSourcesListResponse, error) {
	if err := r.Send(c); err != nil {
		return GetSourcesListResponse{}, err
	}
	return r.Receive()
}

// GetSourcesListResponse : Response for GetSourcesListRequest.
//
// Since obs-websocket version: 4.3.0.
//
// https://github.com/Palakis/obs-websocket/blob/4.x-current/docs/generated/protocol.md#getsourceslist
type GetSourcesListResponse struct {
	// Array of sources.
	// Required: Yes.
	Sources []map[string]interface{} `json:"sources"`
	// Unique source name.
	// Required: Yes.
	SourcesName string `json:"sources.*.name"`
	// Non-unique source internal type (a.k.a type id).
	// Required: Yes.
	SourcesTypeID string `json:"sources.*.typeId"`
	// Source type.
	// Value is one of the following: "input", "filter", "transition", "scene" or "unknown".
	// Required: Yes.
	SourcesType string `json:"sources.*.type"`
	_response   `json:",squash"`
}

// GetSourceTypesListRequest : Get a list of all available sources types.
//
// Since obs-websocket version: 4.3.0.
//
// https://github.com/Palakis/obs-websocket/blob/4.x-current/docs/generated/protocol.md#getsourcetypeslist
type GetSourceTypesListRequest struct {
	_request `json:",squash"`
	response chan GetSourceTypesListResponse
}

// NewGetSourceTypesListRequest returns a new GetSourceTypesListRequest.
func NewGetSourceTypesListRequest() GetSourceTypesListRequest {
	return GetSourceTypesListRequest{
		_request{
			ID_:   GetMessageID(),
			Type_: "GetSourceTypesList",
			err:   make(chan error, 1),
		},
		make(chan GetSourceTypesListResponse, 1),
	}
}

// Send sends the request.
func (r *GetSourceTypesListRequest) Send(c Client) error {
	if r.sent {
		return ErrAlreadySent
	}
	future, err := c.SendRequest(r)
	if err != nil {
		return err
	}
	r.sent = true
	go func() {
		m := <-future
		var resp GetSourceTypesListResponse
		if err = mapToStruct(m, &resp); err != nil {
			r.err <- err
		} else if resp.Status() != StatusOK {
			r.err <- errors.New(resp.Error())
		} else {
			r.response <- resp
		}
	}()
	return nil
}

// Receive waits for the response.
func (r GetSourceTypesListRequest) Receive() (GetSourceTypesListResponse, error) {
	if !r.sent {
		return GetSourceTypesListResponse{}, ErrNotSent
	}
	if receiveTimeout == 0 {
		select {
		case resp := <-r.response:
			return resp, nil
		case err := <-r.err:
			return GetSourceTypesListResponse{}, err
		}
	} else {
		select {
		case resp := <-r.response:
			return resp, nil
		case err := <-r.err:
			return GetSourceTypesListResponse{}, err
		case <-time.After(receiveTimeout):
			return GetSourceTypesListResponse{}, ErrReceiveTimeout
		}
	}
}

// SendReceive sends the request then immediately waits for the response.
func (r GetSourceTypesListRequest) SendReceive(c Client) (GetSourceTypesListResponse, error) {
	if err := r.Send(c); err != nil {
		return GetSourceTypesListResponse{}, err
	}
	return r.Receive()
}

// GetSourceTypesListResponse : Response for GetSourceTypesListRequest.
//
// Since obs-websocket version: 4.3.0.
//
// https://github.com/Palakis/obs-websocket/blob/4.x-current/docs/generated/protocol.md#getsourcetypeslist
type GetSourceTypesListResponse struct {
	// Array of source types.
	// Required: Yes.
	Types []map[string]interface{} `json:"types"`
	// Non-unique internal source type ID.
	// Required: Yes.
	TypesTypeID string `json:"types.*.typeId"`
	// Display name of the source type.
	// Required: Yes.
	TypesDisplayName string `json:"types.*.displayName"`
	// Type.
	// Value is one of the following: "input", "filter", "transition" or "other".
	// Required: Yes.
	TypesType string `json:"types.*.type"`
	// Default settings of this source type.
	// Required: Yes.
	TypesDefaultSettings map[string]interface{} `json:"types.*.defaultSettings"`
	// Source type capabilities.
	// Required: Yes.
	TypesCaps map[string]interface{} `json:"types.*.caps"`
	// True if source of this type provide frames asynchronously.
	// Required: Yes.
	TypesCapsIsAsync bool `json:"types.*.caps.isAsync"`
	// True if sources of this type provide video.
	// Required: Yes.
	TypesCapsHasVideo bool `json:"types.*.caps.hasVideo"`
	// True if sources of this type provide audio.
	// Required: Yes.
	TypesCapsHasAudio bool `json:"types.*.caps.hasAudio"`
	// True if interaction with this sources of this type is possible.
	// Required: Yes.
	TypesCapsCanInteract bool `json:"types.*.caps.canInteract"`
	// True if sources of this type composite one or more sub-sources.
	// Required: Yes.
	TypesCapsIsComposite bool `json:"types.*.caps.isComposite"`
	// True if sources of this type should not be fully duplicated.
	// Required: Yes.
	TypesCapsDoNotDuplicate bool `json:"types.*.caps.doNotDuplicate"`
	// True if sources of this type may cause a feedback loop if it's audio is monitored and shouldn't be.
	// Required: Yes.
	TypesCapsDoNotSelfMonitor bool `json:"types.*.caps.doNotSelfMonitor"`
	_response                 `json:",squash"`
}

// GetVolumeRequest : Get the volume of the specified source.
//
// Since obs-websocket version: 4.0.0.
//
// https://github.com/Palakis/obs-websocket/blob/4.x-current/docs/generated/protocol.md#getvolume
type GetVolumeRequest struct {
	// Source name.
	// Required: Yes.
	Source   string `json:"source"`
	_request `json:",squash"`
	response chan GetVolumeResponse
}

// NewGetVolumeRequest returns a new GetVolumeRequest.
func NewGetVolumeRequest(source string) GetVolumeRequest {
	return GetVolumeRequest{
		source,
		_request{
			ID_:   GetMessageID(),
			Type_: "GetVolume",
			err:   make(chan error, 1),
		},
		make(chan GetVolumeResponse, 1),
	}
}

// Send sends the request.
func (r *GetVolumeRequest) Send(c Client) error {
	if r.sent {
		return ErrAlreadySent
	}
	future, err := c.SendRequest(r)
	if err != nil {
		return err
	}
	r.sent = true
	go func() {
		m := <-future
		var resp GetVolumeResponse
		if err = mapToStruct(m, &resp); err != nil {
			r.err <- err
		} else if resp.Status() != StatusOK {
			r.err <- errors.New(resp.Error())
		} else {
			r.response <- resp
		}
	}()
	return nil
}

// Receive waits for the response.
func (r GetVolumeRequest) Receive() (GetVolumeResponse, error) {
	if !r.sent {
		return GetVolumeResponse{}, ErrNotSent
	}
	if receiveTimeout == 0 {
		select {
		case resp := <-r.response:
			return resp, nil
		case err := <-r.err:
			return GetVolumeResponse{}, err
		}
	} else {
		select {
		case resp := <-r.response:
			return resp, nil
		case err := <-r.err:
			return GetVolumeResponse{}, err
		case <-time.After(receiveTimeout):
			return GetVolumeResponse{}, ErrReceiveTimeout
		}
	}
}

// SendReceive sends the request then immediately waits for the response.
func (r GetVolumeRequest) SendReceive(c Client) (GetVolumeResponse, error) {
	if err := r.Send(c); err != nil {
		return GetVolumeResponse{}, err
	}
	return r.Receive()
}

// GetVolumeResponse : Response for GetVolumeRequest.
//
// Since obs-websocket version: 4.0.0.
//
// https://github.com/Palakis/obs-websocket/blob/4.x-current/docs/generated/protocol.md#getvolume
type GetVolumeResponse struct {
	// Source name.
	// Required: Yes.
	Name string `json:"name"`
	// Volume of the source.
	// Between `0.0` and `1.0`.
	// Required: Yes.
	Volume float64 `json:"volume"`
	// Indicates whether the source is muted.
	// Required: Yes.
	Muted     bool `json:"muted"`
	_response `json:",squash"`
}

// SetVolumeRequest : Set the volume of the specified source.
//
// Since obs-websocket version: 4.0.0.
//
// https://github.com/Palakis/obs-websocket/blob/4.x-current/docs/generated/protocol.md#setvolume
type SetVolumeRequest struct {
	// Source name.
	// Required: Yes.
	Source string `json:"source"`
	// Desired volume.
	// Must be between `0.0` and `1.0`.
	// Required: Yes.
	Volume   float64 `json:"volume"`
	_request `json:",squash"`
	response chan SetVolumeResponse
}

// NewSetVolumeRequest returns a new SetVolumeRequest.
func NewSetVolumeRequest(
	source string,
	volume float64,
) SetVolumeRequest {
	return SetVolumeRequest{
		source,
		volume,
		_request{
			ID_:   GetMessageID(),
			Type_: "SetVolume",
			err:   make(chan error, 1),
		},
		make(chan SetVolumeResponse, 1),
	}
}

// Send sends the request.
func (r *SetVolumeRequest) Send(c Client) error {
	if r.sent {
		return ErrAlreadySent
	}
	future, err := c.SendRequest(r)
	if err != nil {
		return err
	}
	r.sent = true
	go func() {
		m := <-future
		var resp SetVolumeResponse
		if err = mapToStruct(m, &resp); err != nil {
			r.err <- err
		} else if resp.Status() != StatusOK {
			r.err <- errors.New(resp.Error())
		} else {
			r.response <- resp
		}
	}()
	return nil
}

// Receive waits for the response.
func (r SetVolumeRequest) Receive() (SetVolumeResponse, error) {
	if !r.sent {
		return SetVolumeResponse{}, ErrNotSent
	}
	if receiveTimeout == 0 {
		select {
		case resp := <-r.response:
			return resp, nil
		case err := <-r.err:
			return SetVolumeResponse{}, err
		}
	} else {
		select {
		case resp := <-r.response:
			return resp, nil
		case err := <-r.err:
			return SetVolumeResponse{}, err
		case <-time.After(receiveTimeout):
			return SetVolumeResponse{}, ErrReceiveTimeout
		}
	}
}

// SendReceive sends the request then immediately waits for the response.
func (r SetVolumeRequest) SendReceive(c Client) (SetVolumeResponse, error) {
	if err := r.Send(c); err != nil {
		return SetVolumeResponse{}, err
	}
	return r.Receive()
}

// SetVolumeResponse : Response for SetVolumeRequest.
//
// Since obs-websocket version: 4.0.0.
//
// https://github.com/Palakis/obs-websocket/blob/4.x-current/docs/generated/protocol.md#setvolume
type SetVolumeResponse struct {
	_response `json:",squash"`
}

// GetMuteRequest : Get the mute status of a specified source.
//
// Since obs-websocket version: 4.0.0.
//
// https://github.com/Palakis/obs-websocket/blob/4.x-current/docs/generated/protocol.md#getmute
type GetMuteRequest struct {
	// Source name.
	// Required: Yes.
	Source   string `json:"source"`
	_request `json:",squash"`
	response chan GetMuteResponse
}

// NewGetMuteRequest returns a new GetMuteRequest.
func NewGetMuteRequest(source string) GetMuteRequest {
	return GetMuteRequest{
		source,
		_request{
			ID_:   GetMessageID(),
			Type_: "GetMute",
			err:   make(chan error, 1),
		},
		make(chan GetMuteResponse, 1),
	}
}

// Send sends the request.
func (r *GetMuteRequest) Send(c Client) error {
	if r.sent {
		return ErrAlreadySent
	}
	future, err := c.SendRequest(r)
	if err != nil {
		return err
	}
	r.sent = true
	go func() {
		m := <-future
		var resp GetMuteResponse
		if err = mapToStruct(m, &resp); err != nil {
			r.err <- err
		} else if resp.Status() != StatusOK {
			r.err <- errors.New(resp.Error())
		} else {
			r.response <- resp
		}
	}()
	return nil
}

// Receive waits for the response.
func (r GetMuteRequest) Receive() (GetMuteResponse, error) {
	if !r.sent {
		return GetMuteResponse{}, ErrNotSent
	}
	if receiveTimeout == 0 {
		select {
		case resp := <-r.response:
			return resp, nil
		case err := <-r.err:
			return GetMuteResponse{}, err
		}
	} else {
		select {
		case resp := <-r.response:
			return resp, nil
		case err := <-r.err:
			return GetMuteResponse{}, err
		case <-time.After(receiveTimeout):
			return GetMuteResponse{}, ErrReceiveTimeout
		}
	}
}

// SendReceive sends the request then immediately waits for the response.
func (r GetMuteRequest) SendReceive(c Client) (GetMuteResponse, error) {
	if err := r.Send(c); err != nil {
		return GetMuteResponse{}, err
	}
	return r.Receive()
}

// GetMuteResponse : Response for GetMuteRequest.
//
// Since obs-websocket version: 4.0.0.
//
// https://github.com/Palakis/obs-websocket/blob/4.x-current/docs/generated/protocol.md#getmute
type GetMuteResponse struct {
	// Source name.
	// Required: Yes.
	Name string `json:"name"`
	// Mute status of the source.
	// Required: Yes.
	Muted     bool `json:"muted"`
	_response `json:",squash"`
}

// SetMuteRequest : Sets the mute status of a specified source.
//
// Since obs-websocket version: 4.0.0.
//
// https://github.com/Palakis/obs-websocket/blob/4.x-current/docs/generated/protocol.md#setmute
type SetMuteRequest struct {
	// Source name.
	// Required: Yes.
	Source string `json:"source"`
	// Desired mute status.
	// Required: Yes.
	Mute     bool `json:"mute"`
	_request `json:",squash"`
	response chan SetMuteResponse
}

// NewSetMuteRequest returns a new SetMuteRequest.
func NewSetMuteRequest(
	source string,
	mute bool,
) SetMuteRequest {
	return SetMuteRequest{
		source,
		mute,
		_request{
			ID_:   GetMessageID(),
			Type_: "SetMute",
			err:   make(chan error, 1),
		},
		make(chan SetMuteResponse, 1),
	}
}

// Send sends the request.
func (r *SetMuteRequest) Send(c Client) error {
	if r.sent {
		return ErrAlreadySent
	}
	future, err := c.SendRequest(r)
	if err != nil {
		return err
	}
	r.sent = true
	go func() {
		m := <-future
		var resp SetMuteResponse
		if err = mapToStruct(m, &resp); err != nil {
			r.err <- err
		} else if resp.Status() != StatusOK {
			r.err <- errors.New(resp.Error())
		} else {
			r.response <- resp
		}
	}()
	return nil
}

// Receive waits for the response.
func (r SetMuteRequest) Receive() (SetMuteResponse, error) {
	if !r.sent {
		return SetMuteResponse{}, ErrNotSent
	}
	if receiveTimeout == 0 {
		select {
		case resp := <-r.response:
			return resp, nil
		case err := <-r.err:
			return SetMuteResponse{}, err
		}
	} else {
		select {
		case resp := <-r.response:
			return resp, nil
		case err := <-r.err:
			return SetMuteResponse{}, err
		case <-time.After(receiveTimeout):
			return SetMuteResponse{}, ErrReceiveTimeout
		}
	}
}

// SendReceive sends the request then immediately waits for the response.
func (r SetMuteRequest) SendReceive(c Client) (SetMuteResponse, error) {
	if err := r.Send(c); err != nil {
		return SetMuteResponse{}, err
	}
	return r.Receive()
}

// SetMuteResponse : Response for SetMuteRequest.
//
// Since obs-websocket version: 4.0.0.
//
// https://github.com/Palakis/obs-websocket/blob/4.x-current/docs/generated/protocol.md#setmute
type SetMuteResponse struct {
	_response `json:",squash"`
}

// ToggleMuteRequest : Inverts the mute status of a specified source.
//
// Since obs-websocket version: 4.0.0.
//
// https://github.com/Palakis/obs-websocket/blob/4.x-current/docs/generated/protocol.md#togglemute
type ToggleMuteRequest struct {
	// Source name.
	// Required: Yes.
	Source   string `json:"source"`
	_request `json:",squash"`
	response chan ToggleMuteResponse
}

// NewToggleMuteRequest returns a new ToggleMuteRequest.
func NewToggleMuteRequest(source string) ToggleMuteRequest {
	return ToggleMuteRequest{
		source,
		_request{
			ID_:   GetMessageID(),
			Type_: "ToggleMute",
			err:   make(chan error, 1),
		},
		make(chan ToggleMuteResponse, 1),
	}
}

// Send sends the request.
func (r *ToggleMuteRequest) Send(c Client) error {
	if r.sent {
		return ErrAlreadySent
	}
	future, err := c.SendRequest(r)
	if err != nil {
		return err
	}
	r.sent = true
	go func() {
		m := <-future
		var resp ToggleMuteResponse
		if err = mapToStruct(m, &resp); err != nil {
			r.err <- err
		} else if resp.Status() != StatusOK {
			r.err <- errors.New(resp.Error())
		} else {
			r.response <- resp
		}
	}()
	return nil
}

// Receive waits for the response.
func (r ToggleMuteRequest) Receive() (ToggleMuteResponse, error) {
	if !r.sent {
		return ToggleMuteResponse{}, ErrNotSent
	}
	if receiveTimeout == 0 {
		select {
		case resp := <-r.response:
			return resp, nil
		case err := <-r.err:
			return ToggleMuteResponse{}, err
		}
	} else {
		select {
		case resp := <-r.response:
			return resp, nil
		case err := <-r.err:
			return ToggleMuteResponse{}, err
		case <-time.After(receiveTimeout):
			return ToggleMuteResponse{}, ErrReceiveTimeout
		}
	}
}

// SendReceive sends the request then immediately waits for the response.
func (r ToggleMuteRequest) SendReceive(c Client) (ToggleMuteResponse, error) {
	if err := r.Send(c); err != nil {
		return ToggleMuteResponse{}, err
	}
	return r.Receive()
}

// ToggleMuteResponse : Response for ToggleMuteRequest.
//
// Since obs-websocket version: 4.0.0.
//
// https://github.com/Palakis/obs-websocket/blob/4.x-current/docs/generated/protocol.md#togglemute
type ToggleMuteResponse struct {
	_response `json:",squash"`
}

// SetSyncOffsetRequest : Set the audio sync offset of a specified source.
//
// Since obs-websocket version: 4.2.0.
//
// https://github.com/Palakis/obs-websocket/blob/4.x-current/docs/generated/protocol.md#setsyncoffset
type SetSyncOffsetRequest struct {
	// Source name.
	// Required: Yes.
	Source string `json:"source"`
	// The desired audio sync offset (in nanoseconds).
	// Required: Yes.
	Offset   int `json:"offset"`
	_request `json:",squash"`
	response chan SetSyncOffsetResponse
}

// NewSetSyncOffsetRequest returns a new SetSyncOffsetRequest.
func NewSetSyncOffsetRequest(
	source string,
	offset int,
) SetSyncOffsetRequest {
	return SetSyncOffsetRequest{
		source,
		offset,
		_request{
			ID_:   GetMessageID(),
			Type_: "SetSyncOffset",
			err:   make(chan error, 1),
		},
		make(chan SetSyncOffsetResponse, 1),
	}
}

// Send sends the request.
func (r *SetSyncOffsetRequest) Send(c Client) error {
	if r.sent {
		return ErrAlreadySent
	}
	future, err := c.SendRequest(r)
	if err != nil {
		return err
	}
	r.sent = true
	go func() {
		m := <-future
		var resp SetSyncOffsetResponse
		if err = mapToStruct(m, &resp); err != nil {
			r.err <- err
		} else if resp.Status() != StatusOK {
			r.err <- errors.New(resp.Error())
		} else {
			r.response <- resp
		}
	}()
	return nil
}

// Receive waits for the response.
func (r SetSyncOffsetRequest) Receive() (SetSyncOffsetResponse, error) {
	if !r.sent {
		return SetSyncOffsetResponse{}, ErrNotSent
	}
	if receiveTimeout == 0 {
		select {
		case resp := <-r.response:
			return resp, nil
		case err := <-r.err:
			return SetSyncOffsetResponse{}, err
		}
	} else {
		select {
		case resp := <-r.response:
			return resp, nil
		case err := <-r.err:
			return SetSyncOffsetResponse{}, err
		case <-time.After(receiveTimeout):
			return SetSyncOffsetResponse{}, ErrReceiveTimeout
		}
	}
}

// SendReceive sends the request then immediately waits for the response.
func (r SetSyncOffsetRequest) SendReceive(c Client) (SetSyncOffsetResponse, error) {
	if err := r.Send(c); err != nil {
		return SetSyncOffsetResponse{}, err
	}
	return r.Receive()
}

// SetSyncOffsetResponse : Response for SetSyncOffsetRequest.
//
// Since obs-websocket version: 4.2.0.
//
// https://github.com/Palakis/obs-websocket/blob/4.x-current/docs/generated/protocol.md#setsyncoffset
type SetSyncOffsetResponse struct {
	_response `json:",squash"`
}

// GetSyncOffsetRequest : Get the audio sync offset of a specified source.
//
// Since obs-websocket version: 4.2.0.
//
// https://github.com/Palakis/obs-websocket/blob/4.x-current/docs/generated/protocol.md#getsyncoffset
type GetSyncOffsetRequest struct {
	// Source name.
	// Required: Yes.
	Source   string `json:"source"`
	_request `json:",squash"`
	response chan GetSyncOffsetResponse
}

// NewGetSyncOffsetRequest returns a new GetSyncOffsetRequest.
func NewGetSyncOffsetRequest(source string) GetSyncOffsetRequest {
	return GetSyncOffsetRequest{
		source,
		_request{
			ID_:   GetMessageID(),
			Type_: "GetSyncOffset",
			err:   make(chan error, 1),
		},
		make(chan GetSyncOffsetResponse, 1),
	}
}

// Send sends the request.
func (r *GetSyncOffsetRequest) Send(c Client) error {
	if r.sent {
		return ErrAlreadySent
	}
	future, err := c.SendRequest(r)
	if err != nil {
		return err
	}
	r.sent = true
	go func() {
		m := <-future
		var resp GetSyncOffsetResponse
		if err = mapToStruct(m, &resp); err != nil {
			r.err <- err
		} else if resp.Status() != StatusOK {
			r.err <- errors.New(resp.Error())
		} else {
			r.response <- resp
		}
	}()
	return nil
}

// Receive waits for the response.
func (r GetSyncOffsetRequest) Receive() (GetSyncOffsetResponse, error) {
	if !r.sent {
		return GetSyncOffsetResponse{}, ErrNotSent
	}
	if receiveTimeout == 0 {
		select {
		case resp := <-r.response:
			return resp, nil
		case err := <-r.err:
			return GetSyncOffsetResponse{}, err
		}
	} else {
		select {
		case resp := <-r.response:
			return resp, nil
		case err := <-r.err:
			return GetSyncOffsetResponse{}, err
		case <-time.After(receiveTimeout):
			return GetSyncOffsetResponse{}, ErrReceiveTimeout
		}
	}
}

// SendReceive sends the request then immediately waits for the response.
func (r GetSyncOffsetRequest) SendReceive(c Client) (GetSyncOffsetResponse, error) {
	if err := r.Send(c); err != nil {
		return GetSyncOffsetResponse{}, err
	}
	return r.Receive()
}

// GetSyncOffsetResponse : Response for GetSyncOffsetRequest.
//
// Since obs-websocket version: 4.2.0.
//
// https://github.com/Palakis/obs-websocket/blob/4.x-current/docs/generated/protocol.md#getsyncoffset
type GetSyncOffsetResponse struct {
	// Source name.
	// Required: Yes.
	Name string `json:"name"`
	// The audio sync offset (in nanoseconds).
	// Required: Yes.
	Offset    int `json:"offset"`
	_response `json:",squash"`
}

// GetSourceSettingsRequest : Get settings of the specified source.
//
// Since obs-websocket version: 4.3.0.
//
// https://github.com/Palakis/obs-websocket/blob/4.x-current/docs/generated/protocol.md#getsourcesettings
type GetSourceSettingsRequest struct {
	// Source name.
	// Required: Yes.
	SourceName string `json:"sourceName"`
	// Type of the specified source.
	// Useful for type-checking if you expect a specific settings schema.
	// Required: No.
	SourceType string `json:"sourceType"`
	_request   `json:",squash"`
	response   chan GetSourceSettingsResponse
}

// NewGetSourceSettingsRequest returns a new GetSourceSettingsRequest.
func NewGetSourceSettingsRequest(
	sourceName string,
	sourceType string,
) GetSourceSettingsRequest {
	return GetSourceSettingsRequest{
		sourceName,
		sourceType,
		_request{
			ID_:   GetMessageID(),
			Type_: "GetSourceSettings",
			err:   make(chan error, 1),
		},
		make(chan GetSourceSettingsResponse, 1),
	}
}

// Send sends the request.
func (r *GetSourceSettingsRequest) Send(c Client) error {
	if r.sent {
		return ErrAlreadySent
	}
	future, err := c.SendRequest(r)
	if err != nil {
		return err
	}
	r.sent = true
	go func() {
		m := <-future
		var resp GetSourceSettingsResponse
		if err = mapToStruct(m, &resp); err != nil {
			r.err <- err
		} else if resp.Status() != StatusOK {
			r.err <- errors.New(resp.Error())
		} else {
			r.response <- resp
		}
	}()
	return nil
}

// Receive waits for the response.
func (r GetSourceSettingsRequest) Receive() (GetSourceSettingsResponse, error) {
	if !r.sent {
		return GetSourceSettingsResponse{}, ErrNotSent
	}
	if receiveTimeout == 0 {
		select {
		case resp := <-r.response:
			return resp, nil
		case err := <-r.err:
			return GetSourceSettingsResponse{}, err
		}
	} else {
		select {
		case resp := <-r.response:
			return resp, nil
		case err := <-r.err:
			return GetSourceSettingsResponse{}, err
		case <-time.After(receiveTimeout):
			return GetSourceSettingsResponse{}, ErrReceiveTimeout
		}
	}
}

// SendReceive sends the request then immediately waits for the response.
func (r GetSourceSettingsRequest) SendReceive(c Client) (GetSourceSettingsResponse, error) {
	if err := r.Send(c); err != nil {
		return GetSourceSettingsResponse{}, err
	}
	return r.Receive()
}

// GetSourceSettingsResponse : Response for GetSourceSettingsRequest.
//
// Since obs-websocket version: 4.3.0.
//
// https://github.com/Palakis/obs-websocket/blob/4.x-current/docs/generated/protocol.md#getsourcesettings
type GetSourceSettingsResponse struct {
	// Source name.
	// Required: Yes.
	SourceName string `json:"sourceName"`
	// Type of the specified source.
	// Required: Yes.
	SourceType string `json:"sourceType"`
	// Source settings (varies between source types, may require some probing around).
	// Required: Yes.
	SourceSettings map[string]interface{} `json:"sourceSettings"`
	_response      `json:",squash"`
}

// SetSourceSettingsRequest : Set settings of the specified source.
//
// Since obs-websocket version: 4.3.0.
//
// https://github.com/Palakis/obs-websocket/blob/4.x-current/docs/generated/protocol.md#setsourcesettings
type SetSourceSettingsRequest struct {
	// Source name.
	// Required: Yes.
	SourceName string `json:"sourceName"`
	// Type of the specified source.
	// Useful for type-checking to avoid settings a set of settings incompatible with the actual source's type.
	// Required: No.
	SourceType string `json:"sourceType"`
	// Source settings (varies between source types, may require some probing around).
	// Required: Yes.
	SourceSettings map[string]interface{} `json:"sourceSettings"`
	_request       `json:",squash"`
	response       chan SetSourceSettingsResponse
}

// NewSetSourceSettingsRequest returns a new SetSourceSettingsRequest.
func NewSetSourceSettingsRequest(
	sourceName string,
	sourceType string,
	sourceSettings map[string]interface{},
) SetSourceSettingsRequest {
	return SetSourceSettingsRequest{
		sourceName,
		sourceType,
		sourceSettings,
		_request{
			ID_:   GetMessageID(),
			Type_: "SetSourceSettings",
			err:   make(chan error, 1),
		},
		make(chan SetSourceSettingsResponse, 1),
	}
}

// Send sends the request.
func (r *SetSourceSettingsRequest) Send(c Client) error {
	if r.sent {
		return ErrAlreadySent
	}
	future, err := c.SendRequest(r)
	if err != nil {
		return err
	}
	r.sent = true
	go func() {
		m := <-future
		var resp SetSourceSettingsResponse
		if err = mapToStruct(m, &resp); err != nil {
			r.err <- err
		} else if resp.Status() != StatusOK {
			r.err <- errors.New(resp.Error())
		} else {
			r.response <- resp
		}
	}()
	return nil
}

// Receive waits for the response.
func (r SetSourceSettingsRequest) Receive() (SetSourceSettingsResponse, error) {
	if !r.sent {
		return SetSourceSettingsResponse{}, ErrNotSent
	}
	if receiveTimeout == 0 {
		select {
		case resp := <-r.response:
			return resp, nil
		case err := <-r.err:
			return SetSourceSettingsResponse{}, err
		}
	} else {
		select {
		case resp := <-r.response:
			return resp, nil
		case err := <-r.err:
			return SetSourceSettingsResponse{}, err
		case <-time.After(receiveTimeout):
			return SetSourceSettingsResponse{}, ErrReceiveTimeout
		}
	}
}

// SendReceive sends the request then immediately waits for the response.
func (r SetSourceSettingsRequest) SendReceive(c Client) (SetSourceSettingsResponse, error) {
	if err := r.Send(c); err != nil {
		return SetSourceSettingsResponse{}, err
	}
	return r.Receive()
}

// SetSourceSettingsResponse : Response for SetSourceSettingsRequest.
//
// Since obs-websocket version: 4.3.0.
//
// https://github.com/Palakis/obs-websocket/blob/4.x-current/docs/generated/protocol.md#setsourcesettings
type SetSourceSettingsResponse struct {
	// Source name.
	// Required: Yes.
	SourceName string `json:"sourceName"`
	// Type of the specified source.
	// Required: Yes.
	SourceType string `json:"sourceType"`
	// Updated source settings.
	// Required: Yes.
	SourceSettings map[string]interface{} `json:"sourceSettings"`
	_response      `json:",squash"`
}

// GetTextGDIPlusPropertiesRequest : Get the current properties of a Text GDI Plus source.
//
// Since obs-websocket version: 4.1.0.
//
// https://github.com/Palakis/obs-websocket/blob/4.x-current/docs/generated/protocol.md#gettextgdiplusproperties
type GetTextGDIPlusPropertiesRequest struct {
	// Source name.
	// Required: Yes.
	Source   string `json:"source"`
	_request `json:",squash"`
	response chan GetTextGDIPlusPropertiesResponse
}

// NewGetTextGDIPlusPropertiesRequest returns a new GetTextGDIPlusPropertiesRequest.
func NewGetTextGDIPlusPropertiesRequest(source string) GetTextGDIPlusPropertiesRequest {
	return GetTextGDIPlusPropertiesRequest{
		source,
		_request{
			ID_:   GetMessageID(),
			Type_: "GetTextGDIPlusProperties",
			err:   make(chan error, 1),
		},
		make(chan GetTextGDIPlusPropertiesResponse, 1),
	}
}

// Send sends the request.
func (r *GetTextGDIPlusPropertiesRequest) Send(c Client) error {
	if r.sent {
		return ErrAlreadySent
	}
	future, err := c.SendRequest(r)
	if err != nil {
		return err
	}
	r.sent = true
	go func() {
		m := <-future
		var resp GetTextGDIPlusPropertiesResponse
		if err = mapToStruct(m, &resp); err != nil {
			r.err <- err
		} else if resp.Status() != StatusOK {
			r.err <- errors.New(resp.Error())
		} else {
			r.response <- resp
		}
	}()
	return nil
}

// Receive waits for the response.
func (r GetTextGDIPlusPropertiesRequest) Receive() (GetTextGDIPlusPropertiesResponse, error) {
	if !r.sent {
		return GetTextGDIPlusPropertiesResponse{}, ErrNotSent
	}
	if receiveTimeout == 0 {
		select {
		case resp := <-r.response:
			return resp, nil
		case err := <-r.err:
			return GetTextGDIPlusPropertiesResponse{}, err
		}
	} else {
		select {
		case resp := <-r.response:
			return resp, nil
		case err := <-r.err:
			return GetTextGDIPlusPropertiesResponse{}, err
		case <-time.After(receiveTimeout):
			return GetTextGDIPlusPropertiesResponse{}, ErrReceiveTimeout
		}
	}
}

// SendReceive sends the request then immediately waits for the response.
func (r GetTextGDIPlusPropertiesRequest) SendReceive(c Client) (GetTextGDIPlusPropertiesResponse, error) {
	if err := r.Send(c); err != nil {
		return GetTextGDIPlusPropertiesResponse{}, err
	}
	return r.Receive()
}

// GetTextGDIPlusPropertiesResponse : Response for GetTextGDIPlusPropertiesRequest.
//
// Since obs-websocket version: 4.1.0.
//
// https://github.com/Palakis/obs-websocket/blob/4.x-current/docs/generated/protocol.md#gettextgdiplusproperties
type GetTextGDIPlusPropertiesResponse struct {
	// Source name.
	// Required: Yes.
	Source string `json:"source"`
	// Text Alignment ("left", "center", "right").
	// Required: Yes.
	Align string `json:"align"`
	// Background color.
	// Required: Yes.
	BkColor int `json:"bk-color"`
	// Background opacity (0-100).
	// Required: Yes.
	BkOpacity int `json:"bk-opacity"`
	// Chat log.
	// Required: Yes.
	Chatlog bool `json:"chatlog"`
	// Chat log lines.
	// Required: Yes.
	ChatlogLines int `json:"chatlog_lines"`
	// Text color.
	// Required: Yes.
	Color int `json:"color"`
	// Extents wrap.
	// Required: Yes.
	Extents bool `json:"extents"`
	// Extents cx.
	// Required: Yes.
	ExtentsCx int `json:"extents_cx"`
	// Extents cy.
	// Required: Yes.
	ExtentsCy int `json:"extents_cy"`
	// File path name.
	// Required: Yes.
	File string `json:"file"`
	// Read text from the specified file.
	// Required: Yes.
	ReadFromFile bool `json:"read_from_file"`
	// Holds data for the font.
	// Ex: `"font": { "face": "Arial", "flags": 0, "size": 150, "style": "" }`.
	// Required: Yes.
	Font map[string]interface{} `json:"font"`
	// Font face.
	// Required: Yes.
	FontFace string `json:"font.face"`
	// Font text styling flag.
	// `Bold=1, Italic=2, Bold Italic=3, Underline=5, Strikeout=8`.
	// Required: Yes.
	FontFlags int `json:"font.flags"`
	// Font text size.
	// Required: Yes.
	FontSize int `json:"font.size"`
	// Font Style (unknown function).
	// Required: Yes.
	FontStyle string `json:"font.style"`
	// Gradient enabled.
	// Required: Yes.
	Gradient bool `json:"gradient"`
	// Gradient color.
	// Required: Yes.
	GradientColor int `json:"gradient_color"`
	// Gradient direction.
	// Required: Yes.
	GradientDir float64 `json:"gradient_dir"`
	// Gradient opacity (0-100).
	// Required: Yes.
	GradientOpacity int `json:"gradient_opacity"`
	// Outline.
	// Required: Yes.
	Outline bool `json:"outline"`
	// Outline color.
	// Required: Yes.
	OutlineColor int `json:"outline_color"`
	// Outline size.
	// Required: Yes.
	OutlineSize int `json:"outline_size"`
	// Outline opacity (0-100).
	// Required: Yes.
	OutlineOpacity int `json:"outline_opacity"`
	// Text content to be displayed.
	// Required: Yes.
	Text string `json:"text"`
	// Text vertical alignment ("top", "center", "bottom").
	// Required: Yes.
	Valign string `json:"valign"`
	// Vertical text enabled.
	// Required: Yes.
	Vertical  bool `json:"vertical"`
	_response `json:",squash"`
}

// SetTextGDIPlusPropertiesRequest : Set the current properties of a Text GDI Plus source.
//
// Since obs-websocket version: 4.1.0.
//
// https://github.com/Palakis/obs-websocket/blob/4.x-current/docs/generated/protocol.md#settextgdiplusproperties
type SetTextGDIPlusPropertiesRequest struct {
	// Name of the source.
	// Required: Yes.
	Source string `json:"source"`
	// Text Alignment ("left", "center", "right").
	// Required: No.
	Align string `json:"align"`
	// Background color.
	// Required: No.
	BkColor int `json:"bk-color"`
	// Background opacity (0-100).
	// Required: No.
	BkOpacity int `json:"bk-opacity"`
	// Chat log.
	// Required: No.
	Chatlog bool `json:"chatlog"`
	// Chat log lines.
	// Required: No.
	ChatlogLines int `json:"chatlog_lines"`
	// Text color.
	// Required: No.
	Color int `json:"color"`
	// Extents wrap.
	// Required: No.
	Extents bool `json:"extents"`
	// Extents cx.
	// Required: No.
	ExtentsCx int `json:"extents_cx"`
	// Extents cy.
	// Required: No.
	ExtentsCy int `json:"extents_cy"`
	// File path name.
	// Required: No.
	File string `json:"file"`
	// Read text from the specified file.
	// Required: No.
	ReadFromFile bool `json:"read_from_file"`
	// Holds data for the font.
	// Ex: `"font": { "face": "Arial", "flags": 0, "size": 150, "style": "" }`.
	// Required: No.
	Font map[string]interface{} `json:"font"`
	// Font face.
	// Required: No.
	FontFace string `json:"font.face"`
	// Font text styling flag.
	// `Bold=1, Italic=2, Bold Italic=3, Underline=5, Strikeout=8`.
	// Required: No.
	FontFlags int `json:"font.flags"`
	// Font text size.
	// Required: No.
	FontSize int `json:"font.size"`
	// Font Style (unknown function).
	// Required: No.
	FontStyle string `json:"font.style"`
	// Gradient enabled.
	// Required: No.
	Gradient bool `json:"gradient"`
	// Gradient color.
	// Required: No.
	GradientColor int `json:"gradient_color"`
	// Gradient direction.
	// Required: No.
	GradientDir float64 `json:"gradient_dir"`
	// Gradient opacity (0-100).
	// Required: No.
	GradientOpacity int `json:"gradient_opacity"`
	// Outline.
	// Required: No.
	Outline bool `json:"outline"`
	// Outline color.
	// Required: No.
	OutlineColor int `json:"outline_color"`
	// Outline size.
	// Required: No.
	OutlineSize int `json:"outline_size"`
	// Outline opacity (0-100).
	// Required: No.
	OutlineOpacity int `json:"outline_opacity"`
	// Text content to be displayed.
	// Required: No.
	Text string `json:"text"`
	// Text vertical alignment ("top", "center", "bottom").
	// Required: No.
	Valign string `json:"valign"`
	// Vertical text enabled.
	// Required: No.
	Vertical bool `json:"vertical"`
	// Visibility of the scene item.
	// Required: No.
	Render   bool `json:"render"`
	_request `json:",squash"`
	response chan SetTextGDIPlusPropertiesResponse
}

// NewSetTextGDIPlusPropertiesRequest returns a new SetTextGDIPlusPropertiesRequest.
func NewSetTextGDIPlusPropertiesRequest(
	source string,
	align string,
	bkColor int,
	bkOpacity int,
	chatlog bool,
	chatlogLines int,
	color int,
	extents bool,
	extentsCx int,
	extentsCy int,
	file string,
	readFromFile bool,
	font map[string]interface{},
	fontFace string,
	fontFlags int,
	fontSize int,
	fontStyle string,
	gradient bool,
	gradientColor int,
	gradientDir float64,
	gradientOpacity int,
	outline bool,
	outlineColor int,
	outlineSize int,
	outlineOpacity int,
	text string,
	valign string,
	vertical bool,
	render bool,
) SetTextGDIPlusPropertiesRequest {
	return SetTextGDIPlusPropertiesRequest{
		source,
		align,
		bkColor,
		bkOpacity,
		chatlog,
		chatlogLines,
		color,
		extents,
		extentsCx,
		extentsCy,
		file,
		readFromFile,
		font,
		fontFace,
		fontFlags,
		fontSize,
		fontStyle,
		gradient,
		gradientColor,
		gradientDir,
		gradientOpacity,
		outline,
		outlineColor,
		outlineSize,
		outlineOpacity,
		text,
		valign,
		vertical,
		render,
		_request{
			ID_:   GetMessageID(),
			Type_: "SetTextGDIPlusProperties",
			err:   make(chan error, 1),
		},
		make(chan SetTextGDIPlusPropertiesResponse, 1),
	}
}

// Send sends the request.
func (r *SetTextGDIPlusPropertiesRequest) Send(c Client) error {
	if r.sent {
		return ErrAlreadySent
	}
	future, err := c.SendRequest(r)
	if err != nil {
		return err
	}
	r.sent = true
	go func() {
		m := <-future
		var resp SetTextGDIPlusPropertiesResponse
		if err = mapToStruct(m, &resp); err != nil {
			r.err <- err
		} else if resp.Status() != StatusOK {
			r.err <- errors.New(resp.Error())
		} else {
			r.response <- resp
		}
	}()
	return nil
}

// Receive waits for the response.
func (r SetTextGDIPlusPropertiesRequest) Receive() (SetTextGDIPlusPropertiesResponse, error) {
	if !r.sent {
		return SetTextGDIPlusPropertiesResponse{}, ErrNotSent
	}
	if receiveTimeout == 0 {
		select {
		case resp := <-r.response:
			return resp, nil
		case err := <-r.err:
			return SetTextGDIPlusPropertiesResponse{}, err
		}
	} else {
		select {
		case resp := <-r.response:
			return resp, nil
		case err := <-r.err:
			return SetTextGDIPlusPropertiesResponse{}, err
		case <-time.After(receiveTimeout):
			return SetTextGDIPlusPropertiesResponse{}, ErrReceiveTimeout
		}
	}
}

// SendReceive sends the request then immediately waits for the response.
func (r SetTextGDIPlusPropertiesRequest) SendReceive(c Client) (SetTextGDIPlusPropertiesResponse, error) {
	if err := r.Send(c); err != nil {
		return SetTextGDIPlusPropertiesResponse{}, err
	}
	return r.Receive()
}

// SetTextGDIPlusPropertiesResponse : Response for SetTextGDIPlusPropertiesRequest.
//
// Since obs-websocket version: 4.1.0.
//
// https://github.com/Palakis/obs-websocket/blob/4.x-current/docs/generated/protocol.md#settextgdiplusproperties
type SetTextGDIPlusPropertiesResponse struct {
	_response `json:",squash"`
}

// GetTextFreetype2PropertiesRequest : Get the current properties of a Text Freetype 2 source.
//
// Since obs-websocket version: 4.5.0.
//
// https://github.com/Palakis/obs-websocket/blob/4.x-current/docs/generated/protocol.md#gettextfreetype2properties
type GetTextFreetype2PropertiesRequest struct {
	// Source name.
	// Required: Yes.
	Source   string `json:"source"`
	_request `json:",squash"`
	response chan GetTextFreetype2PropertiesResponse
}

// NewGetTextFreetype2PropertiesRequest returns a new GetTextFreetype2PropertiesRequest.
func NewGetTextFreetype2PropertiesRequest(source string) GetTextFreetype2PropertiesRequest {
	return GetTextFreetype2PropertiesRequest{
		source,
		_request{
			ID_:   GetMessageID(),
			Type_: "GetTextFreetype2Properties",
			err:   make(chan error, 1),
		},
		make(chan GetTextFreetype2PropertiesResponse, 1),
	}
}

// Send sends the request.
func (r *GetTextFreetype2PropertiesRequest) Send(c Client) error {
	if r.sent {
		return ErrAlreadySent
	}
	future, err := c.SendRequest(r)
	if err != nil {
		return err
	}
	r.sent = true
	go func() {
		m := <-future
		var resp GetTextFreetype2PropertiesResponse
		if err = mapToStruct(m, &resp); err != nil {
			r.err <- err
		} else if resp.Status() != StatusOK {
			r.err <- errors.New(resp.Error())
		} else {
			r.response <- resp
		}
	}()
	return nil
}

// Receive waits for the response.
func (r GetTextFreetype2PropertiesRequest) Receive() (GetTextFreetype2PropertiesResponse, error) {
	if !r.sent {
		return GetTextFreetype2PropertiesResponse{}, ErrNotSent
	}
	if receiveTimeout == 0 {
		select {
		case resp := <-r.response:
			return resp, nil
		case err := <-r.err:
			return GetTextFreetype2PropertiesResponse{}, err
		}
	} else {
		select {
		case resp := <-r.response:
			return resp, nil
		case err := <-r.err:
			return GetTextFreetype2PropertiesResponse{}, err
		case <-time.After(receiveTimeout):
			return GetTextFreetype2PropertiesResponse{}, ErrReceiveTimeout
		}
	}
}

// SendReceive sends the request then immediately waits for the response.
func (r GetTextFreetype2PropertiesRequest) SendReceive(c Client) (GetTextFreetype2PropertiesResponse, error) {
	if err := r.Send(c); err != nil {
		return GetTextFreetype2PropertiesResponse{}, err
	}
	return r.Receive()
}

// GetTextFreetype2PropertiesResponse : Response for GetTextFreetype2PropertiesRequest.
//
// Since obs-websocket version: 4.5.0.
//
// https://github.com/Palakis/obs-websocket/blob/4.x-current/docs/generated/protocol.md#gettextfreetype2properties
type GetTextFreetype2PropertiesResponse struct {
	// Source name.
	// Required: Yes.
	Source string `json:"source"`
	// Gradient top color.
	// Required: Yes.
	Color1 int `json:"color1"`
	// Gradient bottom color.
	// Required: Yes.
	Color2 int `json:"color2"`
	// Custom width (0 to disable).
	// Required: Yes.
	CustomWidth int `json:"custom_width"`
	// Drop shadow.
	// Required: Yes.
	DropShadow bool `json:"drop_shadow"`
	// Holds data for the font.
	// Ex: `"font": { "face": "Arial", "flags": 0, "size": 150, "style": "" }`.
	// Required: Yes.
	Font map[string]interface{} `json:"font"`
	// Font face.
	// Required: Yes.
	FontFace string `json:"font.face"`
	// Font text styling flag.
	// `Bold=1, Italic=2, Bold Italic=3, Underline=5, Strikeout=8`.
	// Required: Yes.
	FontFlags int `json:"font.flags"`
	// Font text size.
	// Required: Yes.
	FontSize int `json:"font.size"`
	// Font Style (unknown function).
	// Required: Yes.
	FontStyle string `json:"font.style"`
	// Read text from the specified file.
	// Required: Yes.
	FromFile bool `json:"from_file"`
	// Chat log.
	// Required: Yes.
	LogMode bool `json:"log_mode"`
	// Outline.
	// Required: Yes.
	Outline bool `json:"outline"`
	// Text content to be displayed.
	// Required: Yes.
	Text string `json:"text"`
	// File path.
	// Required: Yes.
	TextFile string `json:"text_file"`
	// Word wrap.
	// Required: Yes.
	WordWrap  bool `json:"word_wrap"`
	_response `json:",squash"`
}

// SetTextFreetype2PropertiesRequest : Set the current properties of a Text Freetype 2 source.
//
// Since obs-websocket version: 4.5.0.
//
// https://github.com/Palakis/obs-websocket/blob/4.x-current/docs/generated/protocol.md#settextfreetype2properties
type SetTextFreetype2PropertiesRequest struct {
	// Source name.
	// Required: Yes.
	Source string `json:"source"`
	// Gradient top color.
	// Required: No.
	Color1 int `json:"color1"`
	// Gradient bottom color.
	// Required: No.
	Color2 int `json:"color2"`
	// Custom width (0 to disable).
	// Required: No.
	CustomWidth int `json:"custom_width"`
	// Drop shadow.
	// Required: No.
	DropShadow bool `json:"drop_shadow"`
	// Holds data for the font.
	// Ex: `"font": { "face": "Arial", "flags": 0, "size": 150, "style": "" }`.
	// Required: No.
	Font map[string]interface{} `json:"font"`
	// Font face.
	// Required: No.
	FontFace string `json:"font.face"`
	// Font text styling flag.
	// `Bold=1, Italic=2, Bold Italic=3, Underline=5, Strikeout=8`.
	// Required: No.
	FontFlags int `json:"font.flags"`
	// Font text size.
	// Required: No.
	FontSize int `json:"font.size"`
	// Font Style (unknown function).
	// Required: No.
	FontStyle string `json:"font.style"`
	// Read text from the specified file.
	// Required: No.
	FromFile bool `json:"from_file"`
	// Chat log.
	// Required: No.
	LogMode bool `json:"log_mode"`
	// Outline.
	// Required: No.
	Outline bool `json:"outline"`
	// Text content to be displayed.
	// Required: No.
	Text string `json:"text"`
	// File path.
	// Required: No.
	TextFile string `json:"text_file"`
	// Word wrap.
	// Required: No.
	WordWrap bool `json:"word_wrap"`
	_request `json:",squash"`
	response chan SetTextFreetype2PropertiesResponse
}

// NewSetTextFreetype2PropertiesRequest returns a new SetTextFreetype2PropertiesRequest.
func NewSetTextFreetype2PropertiesRequest(
	source string,
	color1 int,
	color2 int,
	customWidth int,
	dropShadow bool,
	font map[string]interface{},
	fontFace string,
	fontFlags int,
	fontSize int,
	fontStyle string,
	fromFile bool,
	logMode bool,
	outline bool,
	text string,
	textFile string,
	wordWrap bool,
) SetTextFreetype2PropertiesRequest {
	return SetTextFreetype2PropertiesRequest{
		source,
		color1,
		color2,
		customWidth,
		dropShadow,
		font,
		fontFace,
		fontFlags,
		fontSize,
		fontStyle,
		fromFile,
		logMode,
		outline,
		text,
		textFile,
		wordWrap,
		_request{
			ID_:   GetMessageID(),
			Type_: "SetTextFreetype2Properties",
			err:   make(chan error, 1),
		},
		make(chan SetTextFreetype2PropertiesResponse, 1),
	}
}

// Send sends the request.
func (r *SetTextFreetype2PropertiesRequest) Send(c Client) error {
	if r.sent {
		return ErrAlreadySent
	}
	future, err := c.SendRequest(r)
	if err != nil {
		return err
	}
	r.sent = true
	go func() {
		m := <-future
		var resp SetTextFreetype2PropertiesResponse
		if err = mapToStruct(m, &resp); err != nil {
			r.err <- err
		} else if resp.Status() != StatusOK {
			r.err <- errors.New(resp.Error())
		} else {
			r.response <- resp
		}
	}()
	return nil
}

// Receive waits for the response.
func (r SetTextFreetype2PropertiesRequest) Receive() (SetTextFreetype2PropertiesResponse, error) {
	if !r.sent {
		return SetTextFreetype2PropertiesResponse{}, ErrNotSent
	}
	if receiveTimeout == 0 {
		select {
		case resp := <-r.response:
			return resp, nil
		case err := <-r.err:
			return SetTextFreetype2PropertiesResponse{}, err
		}
	} else {
		select {
		case resp := <-r.response:
			return resp, nil
		case err := <-r.err:
			return SetTextFreetype2PropertiesResponse{}, err
		case <-time.After(receiveTimeout):
			return SetTextFreetype2PropertiesResponse{}, ErrReceiveTimeout
		}
	}
}

// SendReceive sends the request then immediately waits for the response.
func (r SetTextFreetype2PropertiesRequest) SendReceive(c Client) (SetTextFreetype2PropertiesResponse, error) {
	if err := r.Send(c); err != nil {
		return SetTextFreetype2PropertiesResponse{}, err
	}
	return r.Receive()
}

// SetTextFreetype2PropertiesResponse : Response for SetTextFreetype2PropertiesRequest.
//
// Since obs-websocket version: 4.5.0.
//
// https://github.com/Palakis/obs-websocket/blob/4.x-current/docs/generated/protocol.md#settextfreetype2properties
type SetTextFreetype2PropertiesResponse struct {
	_response `json:",squash"`
}

// GetBrowserSourcePropertiesRequest : Get current properties for a Browser Source.
//
// Since obs-websocket version: 4.1.0.
//
// https://github.com/Palakis/obs-websocket/blob/4.x-current/docs/generated/protocol.md#getbrowsersourceproperties
type GetBrowserSourcePropertiesRequest struct {
	// Source name.
	// Required: Yes.
	Source   string `json:"source"`
	_request `json:",squash"`
	response chan GetBrowserSourcePropertiesResponse
}

// NewGetBrowserSourcePropertiesRequest returns a new GetBrowserSourcePropertiesRequest.
func NewGetBrowserSourcePropertiesRequest(source string) GetBrowserSourcePropertiesRequest {
	return GetBrowserSourcePropertiesRequest{
		source,
		_request{
			ID_:   GetMessageID(),
			Type_: "GetBrowserSourceProperties",
			err:   make(chan error, 1),
		},
		make(chan GetBrowserSourcePropertiesResponse, 1),
	}
}

// Send sends the request.
func (r *GetBrowserSourcePropertiesRequest) Send(c Client) error {
	if r.sent {
		return ErrAlreadySent
	}
	future, err := c.SendRequest(r)
	if err != nil {
		return err
	}
	r.sent = true
	go func() {
		m := <-future
		var resp GetBrowserSourcePropertiesResponse
		if err = mapToStruct(m, &resp); err != nil {
			r.err <- err
		} else if resp.Status() != StatusOK {
			r.err <- errors.New(resp.Error())
		} else {
			r.response <- resp
		}
	}()
	return nil
}

// Receive waits for the response.
func (r GetBrowserSourcePropertiesRequest) Receive() (GetBrowserSourcePropertiesResponse, error) {
	if !r.sent {
		return GetBrowserSourcePropertiesResponse{}, ErrNotSent
	}
	if receiveTimeout == 0 {
		select {
		case resp := <-r.response:
			return resp, nil
		case err := <-r.err:
			return GetBrowserSourcePropertiesResponse{}, err
		}
	} else {
		select {
		case resp := <-r.response:
			return resp, nil
		case err := <-r.err:
			return GetBrowserSourcePropertiesResponse{}, err
		case <-time.After(receiveTimeout):
			return GetBrowserSourcePropertiesResponse{}, ErrReceiveTimeout
		}
	}
}

// SendReceive sends the request then immediately waits for the response.
func (r GetBrowserSourcePropertiesRequest) SendReceive(c Client) (GetBrowserSourcePropertiesResponse, error) {
	if err := r.Send(c); err != nil {
		return GetBrowserSourcePropertiesResponse{}, err
	}
	return r.Receive()
}

// GetBrowserSourcePropertiesResponse : Response for GetBrowserSourcePropertiesRequest.
//
// Since obs-websocket version: 4.1.0.
//
// https://github.com/Palakis/obs-websocket/blob/4.x-current/docs/generated/protocol.md#getbrowsersourceproperties
type GetBrowserSourcePropertiesResponse struct {
	// Source name.
	// Required: Yes.
	Source string `json:"source"`
	// Indicates that a local file is in use.
	// Required: Yes.
	IsLocalFile bool `json:"is_local_file"`
	// file path.
	// Required: Yes.
	LocalFile string `json:"local_file"`
	// Url.
	// Required: Yes.
	Url string `json:"url"`
	// CSS to inject.
	// Required: Yes.
	Css string `json:"css"`
	// Width.
	// Required: Yes.
	Width int `json:"width"`
	// Height.
	// Required: Yes.
	Height int `json:"height"`
	// Framerate.
	// Required: Yes.
	FPS int `json:"fps"`
	// Indicates whether the source should be shutdown when not visible.
	// Required: Yes.
	Shutdown  bool `json:"shutdown"`
	_response `json:",squash"`
}

// SetBrowserSourcePropertiesRequest : Set current properties for a Browser Source.
//
// Since obs-websocket version: 4.1.0.
//
// https://github.com/Palakis/obs-websocket/blob/4.x-current/docs/generated/protocol.md#setbrowsersourceproperties
type SetBrowserSourcePropertiesRequest struct {
	// Name of the source.
	// Required: Yes.
	Source string `json:"source"`
	// Indicates that a local file is in use.
	// Required: No.
	IsLocalFile bool `json:"is_local_file"`
	// file path.
	// Required: No.
	LocalFile string `json:"local_file"`
	// Url.
	// Required: No.
	Url string `json:"url"`
	// CSS to inject.
	// Required: No.
	Css string `json:"css"`
	// Width.
	// Required: No.
	Width int `json:"width"`
	// Height.
	// Required: No.
	Height int `json:"height"`
	// Framerate.
	// Required: No.
	FPS int `json:"fps"`
	// Indicates whether the source should be shutdown when not visible.
	// Required: No.
	Shutdown bool `json:"shutdown"`
	// Visibility of the scene item.
	// Required: No.
	Render   bool `json:"render"`
	_request `json:",squash"`
	response chan SetBrowserSourcePropertiesResponse
}

// NewSetBrowserSourcePropertiesRequest returns a new SetBrowserSourcePropertiesRequest.
func NewSetBrowserSourcePropertiesRequest(
	source string,
	isLocalFile bool,
	localFile string,
	url string,
	css string,
	width int,
	height int,
	fps int,
	shutdown bool,
	render bool,
) SetBrowserSourcePropertiesRequest {
	return SetBrowserSourcePropertiesRequest{
		source,
		isLocalFile,
		localFile,
		url,
		css,
		width,
		height,
		fps,
		shutdown,
		render,
		_request{
			ID_:   GetMessageID(),
			Type_: "SetBrowserSourceProperties",
			err:   make(chan error, 1),
		},
		make(chan SetBrowserSourcePropertiesResponse, 1),
	}
}

// Send sends the request.
func (r *SetBrowserSourcePropertiesRequest) Send(c Client) error {
	if r.sent {
		return ErrAlreadySent
	}
	future, err := c.SendRequest(r)
	if err != nil {
		return err
	}
	r.sent = true
	go func() {
		m := <-future
		var resp SetBrowserSourcePropertiesResponse
		if err = mapToStruct(m, &resp); err != nil {
			r.err <- err
		} else if resp.Status() != StatusOK {
			r.err <- errors.New(resp.Error())
		} else {
			r.response <- resp
		}
	}()
	return nil
}

// Receive waits for the response.
func (r SetBrowserSourcePropertiesRequest) Receive() (SetBrowserSourcePropertiesResponse, error) {
	if !r.sent {
		return SetBrowserSourcePropertiesResponse{}, ErrNotSent
	}
	if receiveTimeout == 0 {
		select {
		case resp := <-r.response:
			return resp, nil
		case err := <-r.err:
			return SetBrowserSourcePropertiesResponse{}, err
		}
	} else {
		select {
		case resp := <-r.response:
			return resp, nil
		case err := <-r.err:
			return SetBrowserSourcePropertiesResponse{}, err
		case <-time.After(receiveTimeout):
			return SetBrowserSourcePropertiesResponse{}, ErrReceiveTimeout
		}
	}
}

// SendReceive sends the request then immediately waits for the response.
func (r SetBrowserSourcePropertiesRequest) SendReceive(c Client) (SetBrowserSourcePropertiesResponse, error) {
	if err := r.Send(c); err != nil {
		return SetBrowserSourcePropertiesResponse{}, err
	}
	return r.Receive()
}

// SetBrowserSourcePropertiesResponse : Response for SetBrowserSourcePropertiesRequest.
//
// Since obs-websocket version: 4.1.0.
//
// https://github.com/Palakis/obs-websocket/blob/4.x-current/docs/generated/protocol.md#setbrowsersourceproperties
type SetBrowserSourcePropertiesResponse struct {
	_response `json:",squash"`
}

// GetSpecialSourcesRequest : Get configured special sources like Desktop Audio and Mic/Aux sources.
//
// Since obs-websocket version: 4.1.0.
//
// https://github.com/Palakis/obs-websocket/blob/4.x-current/docs/generated/protocol.md#getspecialsources
type GetSpecialSourcesRequest struct {
	_request `json:",squash"`
	response chan GetSpecialSourcesResponse
}

// NewGetSpecialSourcesRequest returns a new GetSpecialSourcesRequest.
func NewGetSpecialSourcesRequest() GetSpecialSourcesRequest {
	return GetSpecialSourcesRequest{
		_request{
			ID_:   GetMessageID(),
			Type_: "GetSpecialSources",
			err:   make(chan error, 1),
		},
		make(chan GetSpecialSourcesResponse, 1),
	}
}

// Send sends the request.
func (r *GetSpecialSourcesRequest) Send(c Client) error {
	if r.sent {
		return ErrAlreadySent
	}
	future, err := c.SendRequest(r)
	if err != nil {
		return err
	}
	r.sent = true
	go func() {
		m := <-future
		var resp GetSpecialSourcesResponse
		if err = mapToStruct(m, &resp); err != nil {
			r.err <- err
		} else if resp.Status() != StatusOK {
			r.err <- errors.New(resp.Error())
		} else {
			r.response <- resp
		}
	}()
	return nil
}

// Receive waits for the response.
func (r GetSpecialSourcesRequest) Receive() (GetSpecialSourcesResponse, error) {
	if !r.sent {
		return GetSpecialSourcesResponse{}, ErrNotSent
	}
	if receiveTimeout == 0 {
		select {
		case resp := <-r.response:
			return resp, nil
		case err := <-r.err:
			return GetSpecialSourcesResponse{}, err
		}
	} else {
		select {
		case resp := <-r.response:
			return resp, nil
		case err := <-r.err:
			return GetSpecialSourcesResponse{}, err
		case <-time.After(receiveTimeout):
			return GetSpecialSourcesResponse{}, ErrReceiveTimeout
		}
	}
}

// SendReceive sends the request then immediately waits for the response.
func (r GetSpecialSourcesRequest) SendReceive(c Client) (GetSpecialSourcesResponse, error) {
	if err := r.Send(c); err != nil {
		return GetSpecialSourcesResponse{}, err
	}
	return r.Receive()
}

// GetSpecialSourcesResponse : Response for GetSpecialSourcesRequest.
//
// Since obs-websocket version: 4.1.0.
//
// https://github.com/Palakis/obs-websocket/blob/4.x-current/docs/generated/protocol.md#getspecialsources
type GetSpecialSourcesResponse struct {
	// Name of the first Desktop Audio capture source.
	// Required: No.
	Desktop1 string `json:"desktop-1"`
	// Name of the second Desktop Audio capture source.
	// Required: No.
	Desktop2 string `json:"desktop-2"`
	// Name of the first Mic/Aux input source.
	// Required: No.
	Mic1 string `json:"mic-1"`
	// Name of the second Mic/Aux input source.
	// Required: No.
	Mic2 string `json:"mic-2"`
	// NAme of the third Mic/Aux input source.
	// Required: No.
	Mic3      string `json:"mic-3"`
	_response `json:",squash"`
}

// GetSourceFiltersRequest : List filters applied to a source.
//
// Since obs-websocket version: 4.5.0.
//
// https://github.com/Palakis/obs-websocket/blob/4.x-current/docs/generated/protocol.md#getsourcefilters
type GetSourceFiltersRequest struct {
	// Source name.
	// Required: Yes.
	SourceName string `json:"sourceName"`
	_request   `json:",squash"`
	response   chan GetSourceFiltersResponse
}

// NewGetSourceFiltersRequest returns a new GetSourceFiltersRequest.
func NewGetSourceFiltersRequest(sourceName string) GetSourceFiltersRequest {
	return GetSourceFiltersRequest{
		sourceName,
		_request{
			ID_:   GetMessageID(),
			Type_: "GetSourceFilters",
			err:   make(chan error, 1),
		},
		make(chan GetSourceFiltersResponse, 1),
	}
}

// Send sends the request.
func (r *GetSourceFiltersRequest) Send(c Client) error {
	if r.sent {
		return ErrAlreadySent
	}
	future, err := c.SendRequest(r)
	if err != nil {
		return err
	}
	r.sent = true
	go func() {
		m := <-future
		var resp GetSourceFiltersResponse
		if err = mapToStruct(m, &resp); err != nil {
			r.err <- err
		} else if resp.Status() != StatusOK {
			r.err <- errors.New(resp.Error())
		} else {
			r.response <- resp
		}
	}()
	return nil
}

// Receive waits for the response.
func (r GetSourceFiltersRequest) Receive() (GetSourceFiltersResponse, error) {
	if !r.sent {
		return GetSourceFiltersResponse{}, ErrNotSent
	}
	if receiveTimeout == 0 {
		select {
		case resp := <-r.response:
			return resp, nil
		case err := <-r.err:
			return GetSourceFiltersResponse{}, err
		}
	} else {
		select {
		case resp := <-r.response:
			return resp, nil
		case err := <-r.err:
			return GetSourceFiltersResponse{}, err
		case <-time.After(receiveTimeout):
			return GetSourceFiltersResponse{}, ErrReceiveTimeout
		}
	}
}

// SendReceive sends the request then immediately waits for the response.
func (r GetSourceFiltersRequest) SendReceive(c Client) (GetSourceFiltersResponse, error) {
	if err := r.Send(c); err != nil {
		return GetSourceFiltersResponse{}, err
	}
	return r.Receive()
}

// GetSourceFiltersResponse : Response for GetSourceFiltersRequest.
//
// Since obs-websocket version: 4.5.0.
//
// https://github.com/Palakis/obs-websocket/blob/4.x-current/docs/generated/protocol.md#getsourcefilters
type GetSourceFiltersResponse struct {
	// List of filters for the specified source.
	// Required: Yes.
	Filters []map[string]interface{} `json:"filters"`
	// Filter status (enabled or not).
	// Required: Yes.
	FiltersEnabled bool `json:"filters.*.enabled"`
	// Filter type.
	// Required: Yes.
	FiltersType string `json:"filters.*.type"`
	// Filter name.
	// Required: Yes.
	FiltersName string `json:"filters.*.name"`
	// Filter settings.
	// Required: Yes.
	FiltersSettings map[string]interface{} `json:"filters.*.settings"`
	_response       `json:",squash"`
}

// GetSourceFilterInfoRequest : List filters applied to a source.
//
// Since obs-websocket version: 4.7.0.
//
// https://github.com/Palakis/obs-websocket/blob/4.x-current/docs/generated/protocol.md#getsourcefilterinfo
type GetSourceFilterInfoRequest struct {
	// Source name.
	// Required: Yes.
	SourceName string `json:"sourceName"`
	// Source filter name.
	// Required: Yes.
	FilterName string `json:"filterName"`
	_request   `json:",squash"`
	response   chan GetSourceFilterInfoResponse
}

// NewGetSourceFilterInfoRequest returns a new GetSourceFilterInfoRequest.
func NewGetSourceFilterInfoRequest(
	sourceName string,
	filterName string,
) GetSourceFilterInfoRequest {
	return GetSourceFilterInfoRequest{
		sourceName,
		filterName,
		_request{
			ID_:   GetMessageID(),
			Type_: "GetSourceFilterInfo",
			err:   make(chan error, 1),
		},
		make(chan GetSourceFilterInfoResponse, 1),
	}
}

// Send sends the request.
func (r *GetSourceFilterInfoRequest) Send(c Client) error {
	if r.sent {
		return ErrAlreadySent
	}
	future, err := c.SendRequest(r)
	if err != nil {
		return err
	}
	r.sent = true
	go func() {
		m := <-future
		var resp GetSourceFilterInfoResponse
		if err = mapToStruct(m, &resp); err != nil {
			r.err <- err
		} else if resp.Status() != StatusOK {
			r.err <- errors.New(resp.Error())
		} else {
			r.response <- resp
		}
	}()
	return nil
}

// Receive waits for the response.
func (r GetSourceFilterInfoRequest) Receive() (GetSourceFilterInfoResponse, error) {
	if !r.sent {
		return GetSourceFilterInfoResponse{}, ErrNotSent
	}
	if receiveTimeout == 0 {
		select {
		case resp := <-r.response:
			return resp, nil
		case err := <-r.err:
			return GetSourceFilterInfoResponse{}, err
		}
	} else {
		select {
		case resp := <-r.response:
			return resp, nil
		case err := <-r.err:
			return GetSourceFilterInfoResponse{}, err
		case <-time.After(receiveTimeout):
			return GetSourceFilterInfoResponse{}, ErrReceiveTimeout
		}
	}
}

// SendReceive sends the request then immediately waits for the response.
func (r GetSourceFilterInfoRequest) SendReceive(c Client) (GetSourceFilterInfoResponse, error) {
	if err := r.Send(c); err != nil {
		return GetSourceFilterInfoResponse{}, err
	}
	return r.Receive()
}

// GetSourceFilterInfoResponse : Response for GetSourceFilterInfoRequest.
//
// Since obs-websocket version: 4.7.0.
//
// https://github.com/Palakis/obs-websocket/blob/4.x-current/docs/generated/protocol.md#getsourcefilterinfo
type GetSourceFilterInfoResponse struct {
	// Filter status (enabled or not).
	// Required: Yes.
	Enabled bool `json:"enabled"`
	// Filter type.
	// Required: Yes.
	Type_ string `json:"type"`
	// Filter name.
	// Required: Yes.
	Name string `json:"name"`
	// Filter settings.
	// Required: Yes.
	Settings  map[string]interface{} `json:"settings"`
	_response `json:",squash"`
}

// AddFilterToSourceRequest : Add a new filter to a source
// Available source types along with their settings properties are available from `GetSourceTypesList`.
//
// Since obs-websocket version: 4.5.0.
//
// https://github.com/Palakis/obs-websocket/blob/4.x-current/docs/generated/protocol.md#addfiltertosource
type AddFilterToSourceRequest struct {
	// Name of the source on which the filter is added.
	// Required: Yes.
	SourceName string `json:"sourceName"`
	// Name of the new filter.
	// Required: Yes.
	FilterName string `json:"filterName"`
	// Filter type.
	// Required: Yes.
	FilterType string `json:"filterType"`
	// Filter settings.
	// Required: Yes.
	FilterSettings map[string]interface{} `json:"filterSettings"`
	_request       `json:",squash"`
	response       chan AddFilterToSourceResponse
}

// NewAddFilterToSourceRequest returns a new AddFilterToSourceRequest.
func NewAddFilterToSourceRequest(
	sourceName string,
	filterName string,
	filterType string,
	filterSettings map[string]interface{},
) AddFilterToSourceRequest {
	return AddFilterToSourceRequest{
		sourceName,
		filterName,
		filterType,
		filterSettings,
		_request{
			ID_:   GetMessageID(),
			Type_: "AddFilterToSource",
			err:   make(chan error, 1),
		},
		make(chan AddFilterToSourceResponse, 1),
	}
}

// Send sends the request.
func (r *AddFilterToSourceRequest) Send(c Client) error {
	if r.sent {
		return ErrAlreadySent
	}
	future, err := c.SendRequest(r)
	if err != nil {
		return err
	}
	r.sent = true
	go func() {
		m := <-future
		var resp AddFilterToSourceResponse
		if err = mapToStruct(m, &resp); err != nil {
			r.err <- err
		} else if resp.Status() != StatusOK {
			r.err <- errors.New(resp.Error())
		} else {
			r.response <- resp
		}
	}()
	return nil
}

// Receive waits for the response.
func (r AddFilterToSourceRequest) Receive() (AddFilterToSourceResponse, error) {
	if !r.sent {
		return AddFilterToSourceResponse{}, ErrNotSent
	}
	if receiveTimeout == 0 {
		select {
		case resp := <-r.response:
			return resp, nil
		case err := <-r.err:
			return AddFilterToSourceResponse{}, err
		}
	} else {
		select {
		case resp := <-r.response:
			return resp, nil
		case err := <-r.err:
			return AddFilterToSourceResponse{}, err
		case <-time.After(receiveTimeout):
			return AddFilterToSourceResponse{}, ErrReceiveTimeout
		}
	}
}

// SendReceive sends the request then immediately waits for the response.
func (r AddFilterToSourceRequest) SendReceive(c Client) (AddFilterToSourceResponse, error) {
	if err := r.Send(c); err != nil {
		return AddFilterToSourceResponse{}, err
	}
	return r.Receive()
}

// AddFilterToSourceResponse : Response for AddFilterToSourceRequest.
//
// Since obs-websocket version: 4.5.0.
//
// https://github.com/Palakis/obs-websocket/blob/4.x-current/docs/generated/protocol.md#addfiltertosource
type AddFilterToSourceResponse struct {
	_response `json:",squash"`
}

// RemoveFilterFromSourceRequest : Remove a filter from a source.
//
// Since obs-websocket version: 4.5.0.
//
// https://github.com/Palakis/obs-websocket/blob/4.x-current/docs/generated/protocol.md#removefilterfromsource
type RemoveFilterFromSourceRequest struct {
	// Name of the source from which the specified filter is removed.
	// Required: Yes.
	SourceName string `json:"sourceName"`
	// Name of the filter to remove.
	// Required: Yes.
	FilterName string `json:"filterName"`
	_request   `json:",squash"`
	response   chan RemoveFilterFromSourceResponse
}

// NewRemoveFilterFromSourceRequest returns a new RemoveFilterFromSourceRequest.
func NewRemoveFilterFromSourceRequest(
	sourceName string,
	filterName string,
) RemoveFilterFromSourceRequest {
	return RemoveFilterFromSourceRequest{
		sourceName,
		filterName,
		_request{
			ID_:   GetMessageID(),
			Type_: "RemoveFilterFromSource",
			err:   make(chan error, 1),
		},
		make(chan RemoveFilterFromSourceResponse, 1),
	}
}

// Send sends the request.
func (r *RemoveFilterFromSourceRequest) Send(c Client) error {
	if r.sent {
		return ErrAlreadySent
	}
	future, err := c.SendRequest(r)
	if err != nil {
		return err
	}
	r.sent = true
	go func() {
		m := <-future
		var resp RemoveFilterFromSourceResponse
		if err = mapToStruct(m, &resp); err != nil {
			r.err <- err
		} else if resp.Status() != StatusOK {
			r.err <- errors.New(resp.Error())
		} else {
			r.response <- resp
		}
	}()
	return nil
}

// Receive waits for the response.
func (r RemoveFilterFromSourceRequest) Receive() (RemoveFilterFromSourceResponse, error) {
	if !r.sent {
		return RemoveFilterFromSourceResponse{}, ErrNotSent
	}
	if receiveTimeout == 0 {
		select {
		case resp := <-r.response:
			return resp, nil
		case err := <-r.err:
			return RemoveFilterFromSourceResponse{}, err
		}
	} else {
		select {
		case resp := <-r.response:
			return resp, nil
		case err := <-r.err:
			return RemoveFilterFromSourceResponse{}, err
		case <-time.After(receiveTimeout):
			return RemoveFilterFromSourceResponse{}, ErrReceiveTimeout
		}
	}
}

// SendReceive sends the request then immediately waits for the response.
func (r RemoveFilterFromSourceRequest) SendReceive(c Client) (RemoveFilterFromSourceResponse, error) {
	if err := r.Send(c); err != nil {
		return RemoveFilterFromSourceResponse{}, err
	}
	return r.Receive()
}

// RemoveFilterFromSourceResponse : Response for RemoveFilterFromSourceRequest.
//
// Since obs-websocket version: 4.5.0.
//
// https://github.com/Palakis/obs-websocket/blob/4.x-current/docs/generated/protocol.md#removefilterfromsource
type RemoveFilterFromSourceResponse struct {
	_response `json:",squash"`
}

// ReorderSourceFilterRequest : Move a filter in the chain (absolute index positioning).
//
// Since obs-websocket version: 4.5.0.
//
// https://github.com/Palakis/obs-websocket/blob/4.x-current/docs/generated/protocol.md#reordersourcefilter
type ReorderSourceFilterRequest struct {
	// Name of the source to which the filter belongs.
	// Required: Yes.
	SourceName string `json:"sourceName"`
	// Name of the filter to reorder.
	// Required: Yes.
	FilterName string `json:"filterName"`
	// Desired position of the filter in the chain.
	// Required: Yes.
	NewIndex int `json:"newIndex"`
	_request `json:",squash"`
	response chan ReorderSourceFilterResponse
}

// NewReorderSourceFilterRequest returns a new ReorderSourceFilterRequest.
func NewReorderSourceFilterRequest(
	sourceName string,
	filterName string,
	newIndex int,
) ReorderSourceFilterRequest {
	return ReorderSourceFilterRequest{
		sourceName,
		filterName,
		newIndex,
		_request{
			ID_:   GetMessageID(),
			Type_: "ReorderSourceFilter",
			err:   make(chan error, 1),
		},
		make(chan ReorderSourceFilterResponse, 1),
	}
}

// Send sends the request.
func (r *ReorderSourceFilterRequest) Send(c Client) error {
	if r.sent {
		return ErrAlreadySent
	}
	future, err := c.SendRequest(r)
	if err != nil {
		return err
	}
	r.sent = true
	go func() {
		m := <-future
		var resp ReorderSourceFilterResponse
		if err = mapToStruct(m, &resp); err != nil {
			r.err <- err
		} else if resp.Status() != StatusOK {
			r.err <- errors.New(resp.Error())
		} else {
			r.response <- resp
		}
	}()
	return nil
}

// Receive waits for the response.
func (r ReorderSourceFilterRequest) Receive() (ReorderSourceFilterResponse, error) {
	if !r.sent {
		return ReorderSourceFilterResponse{}, ErrNotSent
	}
	if receiveTimeout == 0 {
		select {
		case resp := <-r.response:
			return resp, nil
		case err := <-r.err:
			return ReorderSourceFilterResponse{}, err
		}
	} else {
		select {
		case resp := <-r.response:
			return resp, nil
		case err := <-r.err:
			return ReorderSourceFilterResponse{}, err
		case <-time.After(receiveTimeout):
			return ReorderSourceFilterResponse{}, ErrReceiveTimeout
		}
	}
}

// SendReceive sends the request then immediately waits for the response.
func (r ReorderSourceFilterRequest) SendReceive(c Client) (ReorderSourceFilterResponse, error) {
	if err := r.Send(c); err != nil {
		return ReorderSourceFilterResponse{}, err
	}
	return r.Receive()
}

// ReorderSourceFilterResponse : Response for ReorderSourceFilterRequest.
//
// Since obs-websocket version: 4.5.0.
//
// https://github.com/Palakis/obs-websocket/blob/4.x-current/docs/generated/protocol.md#reordersourcefilter
type ReorderSourceFilterResponse struct {
	_response `json:",squash"`
}

// MoveSourceFilterRequest : Move a filter in the chain (relative positioning).
//
// Since obs-websocket version: 4.5.0.
//
// https://github.com/Palakis/obs-websocket/blob/4.x-current/docs/generated/protocol.md#movesourcefilter
type MoveSourceFilterRequest struct {
	// Name of the source to which the filter belongs.
	// Required: Yes.
	SourceName string `json:"sourceName"`
	// Name of the filter to reorder.
	// Required: Yes.
	FilterName string `json:"filterName"`
	// How to move the filter around in the source's filter chain.
	// Either "up", "down", "top" or "bottom".
	// Required: Yes.
	MovementType string `json:"movementType"`
	_request     `json:",squash"`
	response     chan MoveSourceFilterResponse
}

// NewMoveSourceFilterRequest returns a new MoveSourceFilterRequest.
func NewMoveSourceFilterRequest(
	sourceName string,
	filterName string,
	movementType string,
) MoveSourceFilterRequest {
	return MoveSourceFilterRequest{
		sourceName,
		filterName,
		movementType,
		_request{
			ID_:   GetMessageID(),
			Type_: "MoveSourceFilter",
			err:   make(chan error, 1),
		},
		make(chan MoveSourceFilterResponse, 1),
	}
}

// Send sends the request.
func (r *MoveSourceFilterRequest) Send(c Client) error {
	if r.sent {
		return ErrAlreadySent
	}
	future, err := c.SendRequest(r)
	if err != nil {
		return err
	}
	r.sent = true
	go func() {
		m := <-future
		var resp MoveSourceFilterResponse
		if err = mapToStruct(m, &resp); err != nil {
			r.err <- err
		} else if resp.Status() != StatusOK {
			r.err <- errors.New(resp.Error())
		} else {
			r.response <- resp
		}
	}()
	return nil
}

// Receive waits for the response.
func (r MoveSourceFilterRequest) Receive() (MoveSourceFilterResponse, error) {
	if !r.sent {
		return MoveSourceFilterResponse{}, ErrNotSent
	}
	if receiveTimeout == 0 {
		select {
		case resp := <-r.response:
			return resp, nil
		case err := <-r.err:
			return MoveSourceFilterResponse{}, err
		}
	} else {
		select {
		case resp := <-r.response:
			return resp, nil
		case err := <-r.err:
			return MoveSourceFilterResponse{}, err
		case <-time.After(receiveTimeout):
			return MoveSourceFilterResponse{}, ErrReceiveTimeout
		}
	}
}

// SendReceive sends the request then immediately waits for the response.
func (r MoveSourceFilterRequest) SendReceive(c Client) (MoveSourceFilterResponse, error) {
	if err := r.Send(c); err != nil {
		return MoveSourceFilterResponse{}, err
	}
	return r.Receive()
}

// MoveSourceFilterResponse : Response for MoveSourceFilterRequest.
//
// Since obs-websocket version: 4.5.0.
//
// https://github.com/Palakis/obs-websocket/blob/4.x-current/docs/generated/protocol.md#movesourcefilter
type MoveSourceFilterResponse struct {
	_response `json:",squash"`
}

// SetSourceFilterSettingsRequest : Update settings of a filter.
//
// Since obs-websocket version: 4.5.0.
//
// https://github.com/Palakis/obs-websocket/blob/4.x-current/docs/generated/protocol.md#setsourcefiltersettings
type SetSourceFilterSettingsRequest struct {
	// Name of the source to which the filter belongs.
	// Required: Yes.
	SourceName string `json:"sourceName"`
	// Name of the filter to reconfigure.
	// Required: Yes.
	FilterName string `json:"filterName"`
	// New settings.
	// These will be merged to the current filter settings.
	// Required: Yes.
	FilterSettings map[string]interface{} `json:"filterSettings"`
	_request       `json:",squash"`
	response       chan SetSourceFilterSettingsResponse
}

// NewSetSourceFilterSettingsRequest returns a new SetSourceFilterSettingsRequest.
func NewSetSourceFilterSettingsRequest(
	sourceName string,
	filterName string,
	filterSettings map[string]interface{},
) SetSourceFilterSettingsRequest {
	return SetSourceFilterSettingsRequest{
		sourceName,
		filterName,
		filterSettings,
		_request{
			ID_:   GetMessageID(),
			Type_: "SetSourceFilterSettings",
			err:   make(chan error, 1),
		},
		make(chan SetSourceFilterSettingsResponse, 1),
	}
}

// Send sends the request.
func (r *SetSourceFilterSettingsRequest) Send(c Client) error {
	if r.sent {
		return ErrAlreadySent
	}
	future, err := c.SendRequest(r)
	if err != nil {
		return err
	}
	r.sent = true
	go func() {
		m := <-future
		var resp SetSourceFilterSettingsResponse
		if err = mapToStruct(m, &resp); err != nil {
			r.err <- err
		} else if resp.Status() != StatusOK {
			r.err <- errors.New(resp.Error())
		} else {
			r.response <- resp
		}
	}()
	return nil
}

// Receive waits for the response.
func (r SetSourceFilterSettingsRequest) Receive() (SetSourceFilterSettingsResponse, error) {
	if !r.sent {
		return SetSourceFilterSettingsResponse{}, ErrNotSent
	}
	if receiveTimeout == 0 {
		select {
		case resp := <-r.response:
			return resp, nil
		case err := <-r.err:
			return SetSourceFilterSettingsResponse{}, err
		}
	} else {
		select {
		case resp := <-r.response:
			return resp, nil
		case err := <-r.err:
			return SetSourceFilterSettingsResponse{}, err
		case <-time.After(receiveTimeout):
			return SetSourceFilterSettingsResponse{}, ErrReceiveTimeout
		}
	}
}

// SendReceive sends the request then immediately waits for the response.
func (r SetSourceFilterSettingsRequest) SendReceive(c Client) (SetSourceFilterSettingsResponse, error) {
	if err := r.Send(c); err != nil {
		return SetSourceFilterSettingsResponse{}, err
	}
	return r.Receive()
}

// SetSourceFilterSettingsResponse : Response for SetSourceFilterSettingsRequest.
//
// Since obs-websocket version: 4.5.0.
//
// https://github.com/Palakis/obs-websocket/blob/4.x-current/docs/generated/protocol.md#setsourcefiltersettings
type SetSourceFilterSettingsResponse struct {
	_response `json:",squash"`
}

// SetSourceFilterVisibilityRequest : Change the visibility/enabled state of a filter.
//
// Since obs-websocket version: 4.7.0.
//
// https://github.com/Palakis/obs-websocket/blob/4.x-current/docs/generated/protocol.md#setsourcefiltervisibility
type SetSourceFilterVisibilityRequest struct {
	// Source name.
	// Required: Yes.
	SourceName string `json:"sourceName"`
	// Source filter name.
	// Required: Yes.
	FilterName string `json:"filterName"`
	// New filter state.
	// Required: Yes.
	FilterEnabled bool `json:"filterEnabled"`
	_request      `json:",squash"`
	response      chan SetSourceFilterVisibilityResponse
}

// NewSetSourceFilterVisibilityRequest returns a new SetSourceFilterVisibilityRequest.
func NewSetSourceFilterVisibilityRequest(
	sourceName string,
	filterName string,
	filterEnabled bool,
) SetSourceFilterVisibilityRequest {
	return SetSourceFilterVisibilityRequest{
		sourceName,
		filterName,
		filterEnabled,
		_request{
			ID_:   GetMessageID(),
			Type_: "SetSourceFilterVisibility",
			err:   make(chan error, 1),
		},
		make(chan SetSourceFilterVisibilityResponse, 1),
	}
}

// Send sends the request.
func (r *SetSourceFilterVisibilityRequest) Send(c Client) error {
	if r.sent {
		return ErrAlreadySent
	}
	future, err := c.SendRequest(r)
	if err != nil {
		return err
	}
	r.sent = true
	go func() {
		m := <-future
		var resp SetSourceFilterVisibilityResponse
		if err = mapToStruct(m, &resp); err != nil {
			r.err <- err
		} else if resp.Status() != StatusOK {
			r.err <- errors.New(resp.Error())
		} else {
			r.response <- resp
		}
	}()
	return nil
}

// Receive waits for the response.
func (r SetSourceFilterVisibilityRequest) Receive() (SetSourceFilterVisibilityResponse, error) {
	if !r.sent {
		return SetSourceFilterVisibilityResponse{}, ErrNotSent
	}
	if receiveTimeout == 0 {
		select {
		case resp := <-r.response:
			return resp, nil
		case err := <-r.err:
			return SetSourceFilterVisibilityResponse{}, err
		}
	} else {
		select {
		case resp := <-r.response:
			return resp, nil
		case err := <-r.err:
			return SetSourceFilterVisibilityResponse{}, err
		case <-time.After(receiveTimeout):
			return SetSourceFilterVisibilityResponse{}, ErrReceiveTimeout
		}
	}
}

// SendReceive sends the request then immediately waits for the response.
func (r SetSourceFilterVisibilityRequest) SendReceive(c Client) (SetSourceFilterVisibilityResponse, error) {
	if err := r.Send(c); err != nil {
		return SetSourceFilterVisibilityResponse{}, err
	}
	return r.Receive()
}

// SetSourceFilterVisibilityResponse : Response for SetSourceFilterVisibilityRequest.
//
// Since obs-websocket version: 4.7.0.
//
// https://github.com/Palakis/obs-websocket/blob/4.x-current/docs/generated/protocol.md#setsourcefiltervisibility
type SetSourceFilterVisibilityResponse struct {
	_response `json:",squash"`
}

// TakeSourceScreenshotRequest :
//
// At least `embedPictureFormat` or `saveToFilePath` must be specified.
//
// Clients can specify `width` and `height` parameters to receive scaled pictures
// Aspect ratio is
// preserved if only one of these two parameters is specified.
//
// Since obs-websocket version: 4.6.0.
//
// https://github.com/Palakis/obs-websocket/blob/4.x-current/docs/generated/protocol.md#takesourcescreenshot
type TakeSourceScreenshotRequest struct {
	// Source name.
	// Note that, since scenes are also sources, you can also provide a scene name.
	// Required: Yes.
	SourceName string `json:"sourceName"`
	// Format of the Data URI encoded picture.
	// Can be "png", "jpg", "jpeg" or "bmp" (or any other value supported by Qt's Image module).
	// Required: No.
	EmbedPictureFormat string `json:"embedPictureFormat"`
	// Full file path (file extension included) where the captured image is to be saved.
	// Can be in a format different from `pictureFormat`.
	// Can be a relative path.
	// Required: No.
	SaveToFilePath string `json:"saveToFilePath"`
	// Screenshot width.
	// Defaults to the source's base width.
	// Required: No.
	Width int `json:"width"`
	// Screenshot height.
	// Defaults to the source's base height.
	// Required: No.
	Height   int `json:"height"`
	_request `json:",squash"`
	response chan TakeSourceScreenshotResponse
}

// NewTakeSourceScreenshotRequest returns a new TakeSourceScreenshotRequest.
func NewTakeSourceScreenshotRequest(
	sourceName string,
	embedPictureFormat string,
	saveToFilePath string,
	width int,
	height int,
) TakeSourceScreenshotRequest {
	return TakeSourceScreenshotRequest{
		sourceName,
		embedPictureFormat,
		saveToFilePath,
		width,
		height,
		_request{
			ID_:   GetMessageID(),
			Type_: "TakeSourceScreenshot",
			err:   make(chan error, 1),
		},
		make(chan TakeSourceScreenshotResponse, 1),
	}
}

// Send sends the request.
func (r *TakeSourceScreenshotRequest) Send(c Client) error {
	if r.sent {
		return ErrAlreadySent
	}
	future, err := c.SendRequest(r)
	if err != nil {
		return err
	}
	r.sent = true
	go func() {
		m := <-future
		var resp TakeSourceScreenshotResponse
		if err = mapToStruct(m, &resp); err != nil {
			r.err <- err
		} else if resp.Status() != StatusOK {
			r.err <- errors.New(resp.Error())
		} else {
			r.response <- resp
		}
	}()
	return nil
}

// Receive waits for the response.
func (r TakeSourceScreenshotRequest) Receive() (TakeSourceScreenshotResponse, error) {
	if !r.sent {
		return TakeSourceScreenshotResponse{}, ErrNotSent
	}
	if receiveTimeout == 0 {
		select {
		case resp := <-r.response:
			return resp, nil
		case err := <-r.err:
			return TakeSourceScreenshotResponse{}, err
		}
	} else {
		select {
		case resp := <-r.response:
			return resp, nil
		case err := <-r.err:
			return TakeSourceScreenshotResponse{}, err
		case <-time.After(receiveTimeout):
			return TakeSourceScreenshotResponse{}, ErrReceiveTimeout
		}
	}
}

// SendReceive sends the request then immediately waits for the response.
func (r TakeSourceScreenshotRequest) SendReceive(c Client) (TakeSourceScreenshotResponse, error) {
	if err := r.Send(c); err != nil {
		return TakeSourceScreenshotResponse{}, err
	}
	return r.Receive()
}

// TakeSourceScreenshotResponse : Response for TakeSourceScreenshotRequest.
//
// Since obs-websocket version: 4.6.0.
//
// https://github.com/Palakis/obs-websocket/blob/4.x-current/docs/generated/protocol.md#takesourcescreenshot
type TakeSourceScreenshotResponse struct {
	// Source name.
	// Required: Yes.
	SourceName string `json:"sourceName"`
	// Image Data URI (if `embedPictureFormat` was specified in the request).
	// Required: Yes.
	Img string `json:"img"`
	// Absolute path to the saved image file (if `saveToFilePath` was specified in the request).
	// Required: Yes.
	ImageFile string `json:"imageFile"`
	_response `json:",squash"`
}
